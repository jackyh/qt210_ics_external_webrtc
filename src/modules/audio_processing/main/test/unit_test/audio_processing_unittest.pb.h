// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: audio_processing_unittest.proto

#ifndef PROTOBUF_audio_5fprocessing_5funittest_2eproto__INCLUDED
#define PROTOBUF_audio_5fprocessing_5funittest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace audio_processing_unittest {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();
void protobuf_AssignDesc_audio_5fprocessing_5funittest_2eproto();
void protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto();

class Test;
class Test_Statistic;
class Test_EchoMetrics;
class OutputData;

// ===================================================================

class Test_Statistic : public ::google::protobuf::MessageLite {
 public:
  Test_Statistic();
  virtual ~Test_Statistic();
  
  Test_Statistic(const Test_Statistic& from);
  
  inline Test_Statistic& operator=(const Test_Statistic& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Test_Statistic& default_instance();
  
  void Swap(Test_Statistic* other);
  
  // implements Message ----------------------------------------------
  
  Test_Statistic* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Test_Statistic& from);
  void MergeFrom(const Test_Statistic& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 instant = 1;
  inline bool has_instant() const;
  inline void clear_instant();
  static const int kInstantFieldNumber = 1;
  inline ::google::protobuf::int32 instant() const;
  inline void set_instant(::google::protobuf::int32 value);
  
  // optional int32 average = 2;
  inline bool has_average() const;
  inline void clear_average();
  static const int kAverageFieldNumber = 2;
  inline ::google::protobuf::int32 average() const;
  inline void set_average(::google::protobuf::int32 value);
  
  // optional int32 maximum = 3;
  inline bool has_maximum() const;
  inline void clear_maximum();
  static const int kMaximumFieldNumber = 3;
  inline ::google::protobuf::int32 maximum() const;
  inline void set_maximum(::google::protobuf::int32 value);
  
  // optional int32 minimum = 4;
  inline bool has_minimum() const;
  inline void clear_minimum();
  static const int kMinimumFieldNumber = 4;
  inline ::google::protobuf::int32 minimum() const;
  inline void set_minimum(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:audio_processing_unittest.Test.Statistic)
 private:
  inline void set_has_instant();
  inline void clear_has_instant();
  inline void set_has_average();
  inline void clear_has_average();
  inline void set_has_maximum();
  inline void clear_has_maximum();
  inline void set_has_minimum();
  inline void clear_has_minimum();
  
  ::google::protobuf::int32 instant_;
  ::google::protobuf::int32 average_;
  ::google::protobuf::int32 maximum_;
  ::google::protobuf::int32 minimum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();
  friend void protobuf_AssignDesc_audio_5fprocessing_5funittest_2eproto();
  friend void protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto();
  
  void InitAsDefaultInstance();
  static Test_Statistic* default_instance_;
};
// -------------------------------------------------------------------

class Test_EchoMetrics : public ::google::protobuf::MessageLite {
 public:
  Test_EchoMetrics();
  virtual ~Test_EchoMetrics();
  
  Test_EchoMetrics(const Test_EchoMetrics& from);
  
  inline Test_EchoMetrics& operator=(const Test_EchoMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Test_EchoMetrics& default_instance();
  
  void Swap(Test_EchoMetrics* other);
  
  // implements Message ----------------------------------------------
  
  Test_EchoMetrics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Test_EchoMetrics& from);
  void MergeFrom(const Test_EchoMetrics& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .audio_processing_unittest.Test.Statistic residualEchoReturnLoss = 1;
  inline bool has_residualechoreturnloss() const;
  inline void clear_residualechoreturnloss();
  static const int kResidualEchoReturnLossFieldNumber = 1;
  inline const ::audio_processing_unittest::Test_Statistic& residualechoreturnloss() const;
  inline ::audio_processing_unittest::Test_Statistic* mutable_residualechoreturnloss();
  inline ::audio_processing_unittest::Test_Statistic* release_residualechoreturnloss();
  
  // optional .audio_processing_unittest.Test.Statistic echoReturnLoss = 2;
  inline bool has_echoreturnloss() const;
  inline void clear_echoreturnloss();
  static const int kEchoReturnLossFieldNumber = 2;
  inline const ::audio_processing_unittest::Test_Statistic& echoreturnloss() const;
  inline ::audio_processing_unittest::Test_Statistic* mutable_echoreturnloss();
  inline ::audio_processing_unittest::Test_Statistic* release_echoreturnloss();
  
  // optional .audio_processing_unittest.Test.Statistic echoReturnLossEnhancement = 3;
  inline bool has_echoreturnlossenhancement() const;
  inline void clear_echoreturnlossenhancement();
  static const int kEchoReturnLossEnhancementFieldNumber = 3;
  inline const ::audio_processing_unittest::Test_Statistic& echoreturnlossenhancement() const;
  inline ::audio_processing_unittest::Test_Statistic* mutable_echoreturnlossenhancement();
  inline ::audio_processing_unittest::Test_Statistic* release_echoreturnlossenhancement();
  
  // optional .audio_processing_unittest.Test.Statistic aNlp = 4;
  inline bool has_anlp() const;
  inline void clear_anlp();
  static const int kANlpFieldNumber = 4;
  inline const ::audio_processing_unittest::Test_Statistic& anlp() const;
  inline ::audio_processing_unittest::Test_Statistic* mutable_anlp();
  inline ::audio_processing_unittest::Test_Statistic* release_anlp();
  
  // @@protoc_insertion_point(class_scope:audio_processing_unittest.Test.EchoMetrics)
 private:
  inline void set_has_residualechoreturnloss();
  inline void clear_has_residualechoreturnloss();
  inline void set_has_echoreturnloss();
  inline void clear_has_echoreturnloss();
  inline void set_has_echoreturnlossenhancement();
  inline void clear_has_echoreturnlossenhancement();
  inline void set_has_anlp();
  inline void clear_has_anlp();
  
  ::audio_processing_unittest::Test_Statistic* residualechoreturnloss_;
  ::audio_processing_unittest::Test_Statistic* echoreturnloss_;
  ::audio_processing_unittest::Test_Statistic* echoreturnlossenhancement_;
  ::audio_processing_unittest::Test_Statistic* anlp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();
  friend void protobuf_AssignDesc_audio_5fprocessing_5funittest_2eproto();
  friend void protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto();
  
  void InitAsDefaultInstance();
  static Test_EchoMetrics* default_instance_;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::MessageLite {
 public:
  Test();
  virtual ~Test();
  
  Test(const Test& from);
  
  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Test& default_instance();
  
  void Swap(Test* other);
  
  // implements Message ----------------------------------------------
  
  Test* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef Test_Statistic Statistic;
  typedef Test_EchoMetrics EchoMetrics;
  
  // accessors -------------------------------------------------------
  
  // optional int32 numReverseChannels = 1;
  inline bool has_numreversechannels() const;
  inline void clear_numreversechannels();
  static const int kNumReverseChannelsFieldNumber = 1;
  inline ::google::protobuf::int32 numreversechannels() const;
  inline void set_numreversechannels(::google::protobuf::int32 value);
  
  // optional int32 numChannels = 2;
  inline bool has_numchannels() const;
  inline void clear_numchannels();
  static const int kNumChannelsFieldNumber = 2;
  inline ::google::protobuf::int32 numchannels() const;
  inline void set_numchannels(::google::protobuf::int32 value);
  
  // optional int32 sampleRate = 3;
  inline bool has_samplerate() const;
  inline void clear_samplerate();
  static const int kSampleRateFieldNumber = 3;
  inline ::google::protobuf::int32 samplerate() const;
  inline void set_samplerate(::google::protobuf::int32 value);
  
  // optional int32 hasEchoCount = 4;
  inline bool has_hasechocount() const;
  inline void clear_hasechocount();
  static const int kHasEchoCountFieldNumber = 4;
  inline ::google::protobuf::int32 hasechocount() const;
  inline void set_hasechocount(::google::protobuf::int32 value);
  
  // optional int32 hasVoiceCount = 5;
  inline bool has_hasvoicecount() const;
  inline void clear_hasvoicecount();
  static const int kHasVoiceCountFieldNumber = 5;
  inline ::google::protobuf::int32 hasvoicecount() const;
  inline void set_hasvoicecount(::google::protobuf::int32 value);
  
  // optional int32 isSaturatedCount = 6;
  inline bool has_issaturatedcount() const;
  inline void clear_issaturatedcount();
  static const int kIsSaturatedCountFieldNumber = 6;
  inline ::google::protobuf::int32 issaturatedcount() const;
  inline void set_issaturatedcount(::google::protobuf::int32 value);
  
  // optional .audio_processing_unittest.Test.EchoMetrics echoMetrics = 7;
  inline bool has_echometrics() const;
  inline void clear_echometrics();
  static const int kEchoMetricsFieldNumber = 7;
  inline const ::audio_processing_unittest::Test_EchoMetrics& echometrics() const;
  inline ::audio_processing_unittest::Test_EchoMetrics* mutable_echometrics();
  inline ::audio_processing_unittest::Test_EchoMetrics* release_echometrics();
  
  // @@protoc_insertion_point(class_scope:audio_processing_unittest.Test)
 private:
  inline void set_has_numreversechannels();
  inline void clear_has_numreversechannels();
  inline void set_has_numchannels();
  inline void clear_has_numchannels();
  inline void set_has_samplerate();
  inline void clear_has_samplerate();
  inline void set_has_hasechocount();
  inline void clear_has_hasechocount();
  inline void set_has_hasvoicecount();
  inline void clear_has_hasvoicecount();
  inline void set_has_issaturatedcount();
  inline void clear_has_issaturatedcount();
  inline void set_has_echometrics();
  inline void clear_has_echometrics();
  
  ::google::protobuf::int32 numreversechannels_;
  ::google::protobuf::int32 numchannels_;
  ::google::protobuf::int32 samplerate_;
  ::google::protobuf::int32 hasechocount_;
  ::google::protobuf::int32 hasvoicecount_;
  ::google::protobuf::int32 issaturatedcount_;
  ::audio_processing_unittest::Test_EchoMetrics* echometrics_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();
  friend void protobuf_AssignDesc_audio_5fprocessing_5funittest_2eproto();
  friend void protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto();
  
  void InitAsDefaultInstance();
  static Test* default_instance_;
};
// -------------------------------------------------------------------

class OutputData : public ::google::protobuf::MessageLite {
 public:
  OutputData();
  virtual ~OutputData();
  
  OutputData(const OutputData& from);
  
  inline OutputData& operator=(const OutputData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const OutputData& default_instance();
  
  void Swap(OutputData* other);
  
  // implements Message ----------------------------------------------
  
  OutputData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OutputData& from);
  void MergeFrom(const OutputData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .audio_processing_unittest.Test test = 1;
  inline int test_size() const;
  inline void clear_test();
  static const int kTestFieldNumber = 1;
  inline const ::audio_processing_unittest::Test& test(int index) const;
  inline ::audio_processing_unittest::Test* mutable_test(int index);
  inline ::audio_processing_unittest::Test* add_test();
  inline const ::google::protobuf::RepeatedPtrField< ::audio_processing_unittest::Test >&
      test() const;
  inline ::google::protobuf::RepeatedPtrField< ::audio_processing_unittest::Test >*
      mutable_test();
  
  // @@protoc_insertion_point(class_scope:audio_processing_unittest.OutputData)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::audio_processing_unittest::Test > test_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();
  friend void protobuf_AssignDesc_audio_5fprocessing_5funittest_2eproto();
  friend void protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto();
  
  void InitAsDefaultInstance();
  static OutputData* default_instance_;
};
// ===================================================================


// ===================================================================

// Test_Statistic

// optional int32 instant = 1;
inline bool Test_Statistic::has_instant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_Statistic::set_has_instant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_Statistic::clear_has_instant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_Statistic::clear_instant() {
  instant_ = 0;
  clear_has_instant();
}
inline ::google::protobuf::int32 Test_Statistic::instant() const {
  return instant_;
}
inline void Test_Statistic::set_instant(::google::protobuf::int32 value) {
  set_has_instant();
  instant_ = value;
}

// optional int32 average = 2;
inline bool Test_Statistic::has_average() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_Statistic::set_has_average() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_Statistic::clear_has_average() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_Statistic::clear_average() {
  average_ = 0;
  clear_has_average();
}
inline ::google::protobuf::int32 Test_Statistic::average() const {
  return average_;
}
inline void Test_Statistic::set_average(::google::protobuf::int32 value) {
  set_has_average();
  average_ = value;
}

// optional int32 maximum = 3;
inline bool Test_Statistic::has_maximum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_Statistic::set_has_maximum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_Statistic::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_Statistic::clear_maximum() {
  maximum_ = 0;
  clear_has_maximum();
}
inline ::google::protobuf::int32 Test_Statistic::maximum() const {
  return maximum_;
}
inline void Test_Statistic::set_maximum(::google::protobuf::int32 value) {
  set_has_maximum();
  maximum_ = value;
}

// optional int32 minimum = 4;
inline bool Test_Statistic::has_minimum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test_Statistic::set_has_minimum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test_Statistic::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test_Statistic::clear_minimum() {
  minimum_ = 0;
  clear_has_minimum();
}
inline ::google::protobuf::int32 Test_Statistic::minimum() const {
  return minimum_;
}
inline void Test_Statistic::set_minimum(::google::protobuf::int32 value) {
  set_has_minimum();
  minimum_ = value;
}

// -------------------------------------------------------------------

// Test_EchoMetrics

// optional .audio_processing_unittest.Test.Statistic residualEchoReturnLoss = 1;
inline bool Test_EchoMetrics::has_residualechoreturnloss() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_EchoMetrics::set_has_residualechoreturnloss() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_EchoMetrics::clear_has_residualechoreturnloss() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_EchoMetrics::clear_residualechoreturnloss() {
  if (residualechoreturnloss_ != NULL) residualechoreturnloss_->::audio_processing_unittest::Test_Statistic::Clear();
  clear_has_residualechoreturnloss();
}
inline const ::audio_processing_unittest::Test_Statistic& Test_EchoMetrics::residualechoreturnloss() const {
  return residualechoreturnloss_ != NULL ? *residualechoreturnloss_ : *default_instance_->residualechoreturnloss_;
}
inline ::audio_processing_unittest::Test_Statistic* Test_EchoMetrics::mutable_residualechoreturnloss() {
  set_has_residualechoreturnloss();
  if (residualechoreturnloss_ == NULL) residualechoreturnloss_ = new ::audio_processing_unittest::Test_Statistic;
  return residualechoreturnloss_;
}
inline ::audio_processing_unittest::Test_Statistic* Test_EchoMetrics::release_residualechoreturnloss() {
  clear_has_residualechoreturnloss();
  ::audio_processing_unittest::Test_Statistic* temp = residualechoreturnloss_;
  residualechoreturnloss_ = NULL;
  return temp;
}

// optional .audio_processing_unittest.Test.Statistic echoReturnLoss = 2;
inline bool Test_EchoMetrics::has_echoreturnloss() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_EchoMetrics::set_has_echoreturnloss() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_EchoMetrics::clear_has_echoreturnloss() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_EchoMetrics::clear_echoreturnloss() {
  if (echoreturnloss_ != NULL) echoreturnloss_->::audio_processing_unittest::Test_Statistic::Clear();
  clear_has_echoreturnloss();
}
inline const ::audio_processing_unittest::Test_Statistic& Test_EchoMetrics::echoreturnloss() const {
  return echoreturnloss_ != NULL ? *echoreturnloss_ : *default_instance_->echoreturnloss_;
}
inline ::audio_processing_unittest::Test_Statistic* Test_EchoMetrics::mutable_echoreturnloss() {
  set_has_echoreturnloss();
  if (echoreturnloss_ == NULL) echoreturnloss_ = new ::audio_processing_unittest::Test_Statistic;
  return echoreturnloss_;
}
inline ::audio_processing_unittest::Test_Statistic* Test_EchoMetrics::release_echoreturnloss() {
  clear_has_echoreturnloss();
  ::audio_processing_unittest::Test_Statistic* temp = echoreturnloss_;
  echoreturnloss_ = NULL;
  return temp;
}

// optional .audio_processing_unittest.Test.Statistic echoReturnLossEnhancement = 3;
inline bool Test_EchoMetrics::has_echoreturnlossenhancement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_EchoMetrics::set_has_echoreturnlossenhancement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_EchoMetrics::clear_has_echoreturnlossenhancement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_EchoMetrics::clear_echoreturnlossenhancement() {
  if (echoreturnlossenhancement_ != NULL) echoreturnlossenhancement_->::audio_processing_unittest::Test_Statistic::Clear();
  clear_has_echoreturnlossenhancement();
}
inline const ::audio_processing_unittest::Test_Statistic& Test_EchoMetrics::echoreturnlossenhancement() const {
  return echoreturnlossenhancement_ != NULL ? *echoreturnlossenhancement_ : *default_instance_->echoreturnlossenhancement_;
}
inline ::audio_processing_unittest::Test_Statistic* Test_EchoMetrics::mutable_echoreturnlossenhancement() {
  set_has_echoreturnlossenhancement();
  if (echoreturnlossenhancement_ == NULL) echoreturnlossenhancement_ = new ::audio_processing_unittest::Test_Statistic;
  return echoreturnlossenhancement_;
}
inline ::audio_processing_unittest::Test_Statistic* Test_EchoMetrics::release_echoreturnlossenhancement() {
  clear_has_echoreturnlossenhancement();
  ::audio_processing_unittest::Test_Statistic* temp = echoreturnlossenhancement_;
  echoreturnlossenhancement_ = NULL;
  return temp;
}

// optional .audio_processing_unittest.Test.Statistic aNlp = 4;
inline bool Test_EchoMetrics::has_anlp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test_EchoMetrics::set_has_anlp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test_EchoMetrics::clear_has_anlp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test_EchoMetrics::clear_anlp() {
  if (anlp_ != NULL) anlp_->::audio_processing_unittest::Test_Statistic::Clear();
  clear_has_anlp();
}
inline const ::audio_processing_unittest::Test_Statistic& Test_EchoMetrics::anlp() const {
  return anlp_ != NULL ? *anlp_ : *default_instance_->anlp_;
}
inline ::audio_processing_unittest::Test_Statistic* Test_EchoMetrics::mutable_anlp() {
  set_has_anlp();
  if (anlp_ == NULL) anlp_ = new ::audio_processing_unittest::Test_Statistic;
  return anlp_;
}
inline ::audio_processing_unittest::Test_Statistic* Test_EchoMetrics::release_anlp() {
  clear_has_anlp();
  ::audio_processing_unittest::Test_Statistic* temp = anlp_;
  anlp_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Test

// optional int32 numReverseChannels = 1;
inline bool Test::has_numreversechannels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_numreversechannels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_numreversechannels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_numreversechannels() {
  numreversechannels_ = 0;
  clear_has_numreversechannels();
}
inline ::google::protobuf::int32 Test::numreversechannels() const {
  return numreversechannels_;
}
inline void Test::set_numreversechannels(::google::protobuf::int32 value) {
  set_has_numreversechannels();
  numreversechannels_ = value;
}

// optional int32 numChannels = 2;
inline bool Test::has_numchannels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::set_has_numchannels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test::clear_has_numchannels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test::clear_numchannels() {
  numchannels_ = 0;
  clear_has_numchannels();
}
inline ::google::protobuf::int32 Test::numchannels() const {
  return numchannels_;
}
inline void Test::set_numchannels(::google::protobuf::int32 value) {
  set_has_numchannels();
  numchannels_ = value;
}

// optional int32 sampleRate = 3;
inline bool Test::has_samplerate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test::set_has_samplerate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test::clear_has_samplerate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test::clear_samplerate() {
  samplerate_ = 0;
  clear_has_samplerate();
}
inline ::google::protobuf::int32 Test::samplerate() const {
  return samplerate_;
}
inline void Test::set_samplerate(::google::protobuf::int32 value) {
  set_has_samplerate();
  samplerate_ = value;
}

// optional int32 hasEchoCount = 4;
inline bool Test::has_hasechocount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test::set_has_hasechocount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test::clear_has_hasechocount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test::clear_hasechocount() {
  hasechocount_ = 0;
  clear_has_hasechocount();
}
inline ::google::protobuf::int32 Test::hasechocount() const {
  return hasechocount_;
}
inline void Test::set_hasechocount(::google::protobuf::int32 value) {
  set_has_hasechocount();
  hasechocount_ = value;
}

// optional int32 hasVoiceCount = 5;
inline bool Test::has_hasvoicecount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Test::set_has_hasvoicecount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Test::clear_has_hasvoicecount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Test::clear_hasvoicecount() {
  hasvoicecount_ = 0;
  clear_has_hasvoicecount();
}
inline ::google::protobuf::int32 Test::hasvoicecount() const {
  return hasvoicecount_;
}
inline void Test::set_hasvoicecount(::google::protobuf::int32 value) {
  set_has_hasvoicecount();
  hasvoicecount_ = value;
}

// optional int32 isSaturatedCount = 6;
inline bool Test::has_issaturatedcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Test::set_has_issaturatedcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Test::clear_has_issaturatedcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Test::clear_issaturatedcount() {
  issaturatedcount_ = 0;
  clear_has_issaturatedcount();
}
inline ::google::protobuf::int32 Test::issaturatedcount() const {
  return issaturatedcount_;
}
inline void Test::set_issaturatedcount(::google::protobuf::int32 value) {
  set_has_issaturatedcount();
  issaturatedcount_ = value;
}

// optional .audio_processing_unittest.Test.EchoMetrics echoMetrics = 7;
inline bool Test::has_echometrics() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Test::set_has_echometrics() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Test::clear_has_echometrics() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Test::clear_echometrics() {
  if (echometrics_ != NULL) echometrics_->::audio_processing_unittest::Test_EchoMetrics::Clear();
  clear_has_echometrics();
}
inline const ::audio_processing_unittest::Test_EchoMetrics& Test::echometrics() const {
  return echometrics_ != NULL ? *echometrics_ : *default_instance_->echometrics_;
}
inline ::audio_processing_unittest::Test_EchoMetrics* Test::mutable_echometrics() {
  set_has_echometrics();
  if (echometrics_ == NULL) echometrics_ = new ::audio_processing_unittest::Test_EchoMetrics;
  return echometrics_;
}
inline ::audio_processing_unittest::Test_EchoMetrics* Test::release_echometrics() {
  clear_has_echometrics();
  ::audio_processing_unittest::Test_EchoMetrics* temp = echometrics_;
  echometrics_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// OutputData

// repeated .audio_processing_unittest.Test test = 1;
inline int OutputData::test_size() const {
  return test_.size();
}
inline void OutputData::clear_test() {
  test_.Clear();
}
inline const ::audio_processing_unittest::Test& OutputData::test(int index) const {
  return test_.Get(index);
}
inline ::audio_processing_unittest::Test* OutputData::mutable_test(int index) {
  return test_.Mutable(index);
}
inline ::audio_processing_unittest::Test* OutputData::add_test() {
  return test_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::audio_processing_unittest::Test >&
OutputData::test() const {
  return test_;
}
inline ::google::protobuf::RepeatedPtrField< ::audio_processing_unittest::Test >*
OutputData::mutable_test() {
  return &test_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace audio_processing_unittest

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_audio_5fprocessing_5funittest_2eproto__INCLUDED
