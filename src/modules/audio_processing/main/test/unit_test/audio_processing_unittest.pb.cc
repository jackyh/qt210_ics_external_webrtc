// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "audio_processing_unittest.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace audio_processing_unittest {

void protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto() {
  delete Test::default_instance_;
  delete Test_Statistic::default_instance_;
  delete Test_EchoMetrics::default_instance_;
  delete OutputData::default_instance_;
}

void protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  Test::default_instance_ = new Test();
  Test_Statistic::default_instance_ = new Test_Statistic();
  Test_EchoMetrics::default_instance_ = new Test_EchoMetrics();
  OutputData::default_instance_ = new OutputData();
  Test::default_instance_->InitAsDefaultInstance();
  Test_Statistic::default_instance_->InitAsDefaultInstance();
  Test_EchoMetrics::default_instance_->InitAsDefaultInstance();
  OutputData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_audio_5fprocessing_5funittest_2eproto {
  StaticDescriptorInitializer_audio_5fprocessing_5funittest_2eproto() {
    protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();
  }
} static_descriptor_initializer_audio_5fprocessing_5funittest_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Test_Statistic::kInstantFieldNumber;
const int Test_Statistic::kAverageFieldNumber;
const int Test_Statistic::kMaximumFieldNumber;
const int Test_Statistic::kMinimumFieldNumber;
#endif  // !_MSC_VER

Test_Statistic::Test_Statistic()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Test_Statistic::InitAsDefaultInstance() {
}

Test_Statistic::Test_Statistic(const Test_Statistic& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Test_Statistic::SharedCtor() {
  _cached_size_ = 0;
  instant_ = 0;
  average_ = 0;
  maximum_ = 0;
  minimum_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_Statistic::~Test_Statistic() {
  SharedDtor();
}

void Test_Statistic::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Test_Statistic::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_Statistic& Test_Statistic::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

Test_Statistic* Test_Statistic::default_instance_ = NULL;

Test_Statistic* Test_Statistic::New() const {
  return new Test_Statistic;
}

void Test_Statistic::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    instant_ = 0;
    average_ = 0;
    maximum_ = 0;
    minimum_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Test_Statistic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 instant = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &instant_)));
          set_has_instant();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_average;
        break;
      }
      
      // optional int32 average = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_average:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &average_)));
          set_has_average();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_maximum;
        break;
      }
      
      // optional int32 maximum = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maximum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maximum_)));
          set_has_maximum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_minimum;
        break;
      }
      
      // optional int32 minimum = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minimum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minimum_)));
          set_has_minimum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Test_Statistic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 instant = 1;
  if (has_instant()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->instant(), output);
  }
  
  // optional int32 average = 2;
  if (has_average()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->average(), output);
  }
  
  // optional int32 maximum = 3;
  if (has_maximum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->maximum(), output);
  }
  
  // optional int32 minimum = 4;
  if (has_minimum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->minimum(), output);
  }
  
}

int Test_Statistic::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 instant = 1;
    if (has_instant()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->instant());
    }
    
    // optional int32 average = 2;
    if (has_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->average());
    }
    
    // optional int32 maximum = 3;
    if (has_maximum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maximum());
    }
    
    // optional int32 minimum = 4;
    if (has_minimum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minimum());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_Statistic::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_Statistic*>(&from));
}

void Test_Statistic::MergeFrom(const Test_Statistic& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_instant()) {
      set_instant(from.instant());
    }
    if (from.has_average()) {
      set_average(from.average());
    }
    if (from.has_maximum()) {
      set_maximum(from.maximum());
    }
    if (from.has_minimum()) {
      set_minimum(from.minimum());
    }
  }
}

void Test_Statistic::CopyFrom(const Test_Statistic& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_Statistic::IsInitialized() const {
  
  return true;
}

void Test_Statistic::Swap(Test_Statistic* other) {
  if (other != this) {
    std::swap(instant_, other->instant_);
    std::swap(average_, other->average_);
    std::swap(maximum_, other->maximum_);
    std::swap(minimum_, other->minimum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Test_Statistic::GetTypeName() const {
  return "audio_processing_unittest.Test.Statistic";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Test_EchoMetrics::kResidualEchoReturnLossFieldNumber;
const int Test_EchoMetrics::kEchoReturnLossFieldNumber;
const int Test_EchoMetrics::kEchoReturnLossEnhancementFieldNumber;
const int Test_EchoMetrics::kANlpFieldNumber;
#endif  // !_MSC_VER

Test_EchoMetrics::Test_EchoMetrics()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Test_EchoMetrics::InitAsDefaultInstance() {
  residualechoreturnloss_ = const_cast< ::audio_processing_unittest::Test_Statistic*>(&::audio_processing_unittest::Test_Statistic::default_instance());
  echoreturnloss_ = const_cast< ::audio_processing_unittest::Test_Statistic*>(&::audio_processing_unittest::Test_Statistic::default_instance());
  echoreturnlossenhancement_ = const_cast< ::audio_processing_unittest::Test_Statistic*>(&::audio_processing_unittest::Test_Statistic::default_instance());
  anlp_ = const_cast< ::audio_processing_unittest::Test_Statistic*>(&::audio_processing_unittest::Test_Statistic::default_instance());
}

Test_EchoMetrics::Test_EchoMetrics(const Test_EchoMetrics& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Test_EchoMetrics::SharedCtor() {
  _cached_size_ = 0;
  residualechoreturnloss_ = NULL;
  echoreturnloss_ = NULL;
  echoreturnlossenhancement_ = NULL;
  anlp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_EchoMetrics::~Test_EchoMetrics() {
  SharedDtor();
}

void Test_EchoMetrics::SharedDtor() {
  if (this != default_instance_) {
    delete residualechoreturnloss_;
    delete echoreturnloss_;
    delete echoreturnlossenhancement_;
    delete anlp_;
  }
}

void Test_EchoMetrics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_EchoMetrics& Test_EchoMetrics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

Test_EchoMetrics* Test_EchoMetrics::default_instance_ = NULL;

Test_EchoMetrics* Test_EchoMetrics::New() const {
  return new Test_EchoMetrics;
}

void Test_EchoMetrics::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_residualechoreturnloss()) {
      if (residualechoreturnloss_ != NULL) residualechoreturnloss_->::audio_processing_unittest::Test_Statistic::Clear();
    }
    if (has_echoreturnloss()) {
      if (echoreturnloss_ != NULL) echoreturnloss_->::audio_processing_unittest::Test_Statistic::Clear();
    }
    if (has_echoreturnlossenhancement()) {
      if (echoreturnlossenhancement_ != NULL) echoreturnlossenhancement_->::audio_processing_unittest::Test_Statistic::Clear();
    }
    if (has_anlp()) {
      if (anlp_ != NULL) anlp_->::audio_processing_unittest::Test_Statistic::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Test_EchoMetrics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .audio_processing_unittest.Test.Statistic residualEchoReturnLoss = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_residualechoreturnloss()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_echoReturnLoss;
        break;
      }
      
      // optional .audio_processing_unittest.Test.Statistic echoReturnLoss = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_echoReturnLoss:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echoreturnloss()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_echoReturnLossEnhancement;
        break;
      }
      
      // optional .audio_processing_unittest.Test.Statistic echoReturnLossEnhancement = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_echoReturnLossEnhancement:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echoreturnlossenhancement()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_aNlp;
        break;
      }
      
      // optional .audio_processing_unittest.Test.Statistic aNlp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_aNlp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_anlp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Test_EchoMetrics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .audio_processing_unittest.Test.Statistic residualEchoReturnLoss = 1;
  if (has_residualechoreturnloss()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->residualechoreturnloss(), output);
  }
  
  // optional .audio_processing_unittest.Test.Statistic echoReturnLoss = 2;
  if (has_echoreturnloss()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->echoreturnloss(), output);
  }
  
  // optional .audio_processing_unittest.Test.Statistic echoReturnLossEnhancement = 3;
  if (has_echoreturnlossenhancement()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->echoreturnlossenhancement(), output);
  }
  
  // optional .audio_processing_unittest.Test.Statistic aNlp = 4;
  if (has_anlp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->anlp(), output);
  }
  
}

int Test_EchoMetrics::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .audio_processing_unittest.Test.Statistic residualEchoReturnLoss = 1;
    if (has_residualechoreturnloss()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->residualechoreturnloss());
    }
    
    // optional .audio_processing_unittest.Test.Statistic echoReturnLoss = 2;
    if (has_echoreturnloss()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->echoreturnloss());
    }
    
    // optional .audio_processing_unittest.Test.Statistic echoReturnLossEnhancement = 3;
    if (has_echoreturnlossenhancement()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->echoreturnlossenhancement());
    }
    
    // optional .audio_processing_unittest.Test.Statistic aNlp = 4;
    if (has_anlp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->anlp());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_EchoMetrics::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_EchoMetrics*>(&from));
}

void Test_EchoMetrics::MergeFrom(const Test_EchoMetrics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_residualechoreturnloss()) {
      mutable_residualechoreturnloss()->::audio_processing_unittest::Test_Statistic::MergeFrom(from.residualechoreturnloss());
    }
    if (from.has_echoreturnloss()) {
      mutable_echoreturnloss()->::audio_processing_unittest::Test_Statistic::MergeFrom(from.echoreturnloss());
    }
    if (from.has_echoreturnlossenhancement()) {
      mutable_echoreturnlossenhancement()->::audio_processing_unittest::Test_Statistic::MergeFrom(from.echoreturnlossenhancement());
    }
    if (from.has_anlp()) {
      mutable_anlp()->::audio_processing_unittest::Test_Statistic::MergeFrom(from.anlp());
    }
  }
}

void Test_EchoMetrics::CopyFrom(const Test_EchoMetrics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_EchoMetrics::IsInitialized() const {
  
  return true;
}

void Test_EchoMetrics::Swap(Test_EchoMetrics* other) {
  if (other != this) {
    std::swap(residualechoreturnloss_, other->residualechoreturnloss_);
    std::swap(echoreturnloss_, other->echoreturnloss_);
    std::swap(echoreturnlossenhancement_, other->echoreturnlossenhancement_);
    std::swap(anlp_, other->anlp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Test_EchoMetrics::GetTypeName() const {
  return "audio_processing_unittest.Test.EchoMetrics";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Test::kNumReverseChannelsFieldNumber;
const int Test::kNumChannelsFieldNumber;
const int Test::kSampleRateFieldNumber;
const int Test::kHasEchoCountFieldNumber;
const int Test::kHasVoiceCountFieldNumber;
const int Test::kIsSaturatedCountFieldNumber;
const int Test::kEchoMetricsFieldNumber;
#endif  // !_MSC_VER

Test::Test()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Test::InitAsDefaultInstance() {
  echometrics_ = const_cast< ::audio_processing_unittest::Test_EchoMetrics*>(&::audio_processing_unittest::Test_EchoMetrics::default_instance());
}

Test::Test(const Test& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Test::SharedCtor() {
  _cached_size_ = 0;
  numreversechannels_ = 0;
  numchannels_ = 0;
  samplerate_ = 0;
  hasechocount_ = 0;
  hasvoicecount_ = 0;
  issaturatedcount_ = 0;
  echometrics_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test::~Test() {
  SharedDtor();
}

void Test::SharedDtor() {
  if (this != default_instance_) {
    delete echometrics_;
  }
}

void Test::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test& Test::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

Test* Test::default_instance_ = NULL;

Test* Test::New() const {
  return new Test;
}

void Test::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    numreversechannels_ = 0;
    numchannels_ = 0;
    samplerate_ = 0;
    hasechocount_ = 0;
    hasvoicecount_ = 0;
    issaturatedcount_ = 0;
    if (has_echometrics()) {
      if (echometrics_ != NULL) echometrics_->::audio_processing_unittest::Test_EchoMetrics::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Test::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 numReverseChannels = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numreversechannels_)));
          set_has_numreversechannels();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_numChannels;
        break;
      }
      
      // optional int32 numChannels = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numChannels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &numchannels_)));
          set_has_numchannels();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sampleRate;
        break;
      }
      
      // optional int32 sampleRate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sampleRate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &samplerate_)));
          set_has_samplerate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_hasEchoCount;
        break;
      }
      
      // optional int32 hasEchoCount = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hasEchoCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hasechocount_)));
          set_has_hasechocount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_hasVoiceCount;
        break;
      }
      
      // optional int32 hasVoiceCount = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hasVoiceCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hasvoicecount_)));
          set_has_hasvoicecount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_isSaturatedCount;
        break;
      }
      
      // optional int32 isSaturatedCount = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isSaturatedCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &issaturatedcount_)));
          set_has_issaturatedcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_echoMetrics;
        break;
      }
      
      // optional .audio_processing_unittest.Test.EchoMetrics echoMetrics = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_echoMetrics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echometrics()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Test::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 numReverseChannels = 1;
  if (has_numreversechannels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->numreversechannels(), output);
  }
  
  // optional int32 numChannels = 2;
  if (has_numchannels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->numchannels(), output);
  }
  
  // optional int32 sampleRate = 3;
  if (has_samplerate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->samplerate(), output);
  }
  
  // optional int32 hasEchoCount = 4;
  if (has_hasechocount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->hasechocount(), output);
  }
  
  // optional int32 hasVoiceCount = 5;
  if (has_hasvoicecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->hasvoicecount(), output);
  }
  
  // optional int32 isSaturatedCount = 6;
  if (has_issaturatedcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->issaturatedcount(), output);
  }
  
  // optional .audio_processing_unittest.Test.EchoMetrics echoMetrics = 7;
  if (has_echometrics()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->echometrics(), output);
  }
  
}

int Test::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 numReverseChannels = 1;
    if (has_numreversechannels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numreversechannels());
    }
    
    // optional int32 numChannels = 2;
    if (has_numchannels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->numchannels());
    }
    
    // optional int32 sampleRate = 3;
    if (has_samplerate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->samplerate());
    }
    
    // optional int32 hasEchoCount = 4;
    if (has_hasechocount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hasechocount());
    }
    
    // optional int32 hasVoiceCount = 5;
    if (has_hasvoicecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hasvoicecount());
    }
    
    // optional int32 isSaturatedCount = 6;
    if (has_issaturatedcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->issaturatedcount());
    }
    
    // optional .audio_processing_unittest.Test.EchoMetrics echoMetrics = 7;
    if (has_echometrics()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->echometrics());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test*>(&from));
}

void Test::MergeFrom(const Test& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_numreversechannels()) {
      set_numreversechannels(from.numreversechannels());
    }
    if (from.has_numchannels()) {
      set_numchannels(from.numchannels());
    }
    if (from.has_samplerate()) {
      set_samplerate(from.samplerate());
    }
    if (from.has_hasechocount()) {
      set_hasechocount(from.hasechocount());
    }
    if (from.has_hasvoicecount()) {
      set_hasvoicecount(from.hasvoicecount());
    }
    if (from.has_issaturatedcount()) {
      set_issaturatedcount(from.issaturatedcount());
    }
    if (from.has_echometrics()) {
      mutable_echometrics()->::audio_processing_unittest::Test_EchoMetrics::MergeFrom(from.echometrics());
    }
  }
}

void Test::CopyFrom(const Test& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test::IsInitialized() const {
  
  return true;
}

void Test::Swap(Test* other) {
  if (other != this) {
    std::swap(numreversechannels_, other->numreversechannels_);
    std::swap(numchannels_, other->numchannels_);
    std::swap(samplerate_, other->samplerate_);
    std::swap(hasechocount_, other->hasechocount_);
    std::swap(hasvoicecount_, other->hasvoicecount_);
    std::swap(issaturatedcount_, other->issaturatedcount_);
    std::swap(echometrics_, other->echometrics_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Test::GetTypeName() const {
  return "audio_processing_unittest.Test";
}


// ===================================================================

#ifndef _MSC_VER
const int OutputData::kTestFieldNumber;
#endif  // !_MSC_VER

OutputData::OutputData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OutputData::InitAsDefaultInstance() {
}

OutputData::OutputData(const OutputData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OutputData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OutputData::~OutputData() {
  SharedDtor();
}

void OutputData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OutputData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OutputData& OutputData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

OutputData* OutputData::default_instance_ = NULL;

OutputData* OutputData::New() const {
  return new OutputData;
}

void OutputData::Clear() {
  test_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OutputData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .audio_processing_unittest.Test test = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_test:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_test()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_test;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag, NULL));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OutputData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .audio_processing_unittest.Test test = 1;
  for (int i = 0; i < this->test_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->test(i), output);
  }
  
}

int OutputData::ByteSize() const {
  int total_size = 0;
  
  // repeated .audio_processing_unittest.Test test = 1;
  total_size += 1 * this->test_size();
  for (int i = 0; i < this->test_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->test(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OutputData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OutputData*>(&from));
}

void OutputData::MergeFrom(const OutputData& from) {
  GOOGLE_CHECK_NE(&from, this);
  test_.MergeFrom(from.test_);
}

void OutputData::CopyFrom(const OutputData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputData::IsInitialized() const {
  
  return true;
}

void OutputData::Swap(OutputData* other) {
  if (other != this) {
    test_.Swap(&other->test_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OutputData::GetTypeName() const {
  return "audio_processing_unittest.OutputData";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace audio_processing_unittest

// @@protoc_insertion_point(global_scope)
